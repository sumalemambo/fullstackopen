/*

# Components

In javascript the following is a function that
does not receive parameters

() => (
  <div>
    <p>Hello world</p>
  </div>
)

the function is then assigned to a constant variable
called App

We will modify the following fuction

const App = () => (
  <div>
    <p>Hello world</p>
  </div>
)

to

const App = () => {
  console.log('Hello from component')
  return (
    <div>
      <p>Hello world</p>
    </div>
  )
}

It is also possible to render dynamic content on the
component as follows

const App = () => {
  const now = new Date()
  const a = 10
  const b = 20

  return (
    <div>
      <p>Hello World, it is {now.toString()}</p>
      <p>
        {a} plus {b} is {a + b}
      </p>
    </div>
  )

# JSX

It seems like React components are returning HTML Markup. However,
that is not the case. The layout of React applications is mostly
written using JSX. Under the hood, JSX returned by React components
is compiled into Javascript.

After compiling our code looks like this

const App = () => {
  const now = new Date()
  const a = 10
  const b = 20
  return React.createElement(
    'div',
    null,
    React.createElement(
      'p', null, 'Hello world, it is ', now.toString()
    ),
    React.createElement(
      'p', null, a, ' plus ', b, ' is ', a + b
    )
  )
}

# Multiple components

Lets modify App.js as follows

const Hello = () => {
  return (
    <div>
      <p>Hello world</p>
    </div>
  )
}

const App = () => {
  return (
    <div>
      <h1>Greetings</h1>
      <Hello />
    </div>
  )
}

Naturally, a component can be used multiple times

const App = () => {
  return (
    <div>
      <h1>Greetings</h1>
      <Hello />
      <Hello />
      <Hello />
    </div>
  )
}

# props: passing data to components

It is posible to pass data to components using so-called props.
Lets modify the hello component as follows:

const Hello = (props) => {
  return (
    <div>
    <p>Hello {props.name}</p>
    </div>
  )
}

Now the function defining the component as a parameter called props.
As an argument, the parameter receives an object, which has fields
corresponding to all the "props" the user of the component defines
(in this case the user of the component is the App component).

The props are defined as follows:

const App = () => {
  return (
    <div>
      <h1>Greetings</h1>
      <Hello name='George' />
      <Hello name='Daisy' />
    </div>
  )
}

There can be arbitrary number of props and their values can be
"hard-coded" strings or the results of Javascript expressions.
If the value of the prop is achieved using Javascript it must be
wrapped with curly braces.

Lets modify the code so that the component Hello uses two props:

const Hello = (props) => {
  return (
    <div>
      <p>
        Hello {props.name}, you are {props.age} years old
      </p>
    </div>
  )
}

const App = () => {
  const name = 'Peter'
  const age = 10

  return (
    <div>
      <h1>Greetings</h1>
      <Hello name='Maya' age={26 + 10} />
      <Hello name={name} age={age} />
    </div>  
  )
}

# Some notes

React has been configured to generate quite clear error messages.
You should advance and very small steps and make sure every change
works as desired. The console should always be open. If the browser
reports error it is not advisable to continue writing more code,
hoping for miracles.

It is also worthwhile to write console.log() commands within your
code. Also React components name should be CAPITALIZED.

The content of a React component (usually) needs to contain
one root element if we try to define the component

const App = () => {
  return (
    <h1>Greetings</h1>
    <Hello name='Maya' age={26 + 10} />
    <Footer />
  )
}

without the outermost div-element the result is an error.
Using a root element is not the only working solution. An
array of components is also a valid solution:

const App = () => {
  return [
    <h1>Greetings</h1>,
    <Hello name='Maya' age={26 + 10} />,
    <Footer />
  ]
}

However, when defining the root component of the application
this is not a particularly wise thing to do, and it makes the code
to look a little bit ugly.

Because the root element is stipulated, we have "extra" div-elements
in the DOM-tree. This can be avoided by using fragments, i.e. by 
wrapping the elements to be returned by the component with an empty
element:

const App = () => {
  const name = 'Peter'
  const age = 10

  return (
    <>
      <h1>Greetings</h1>
      <Hello name='Maya' age={26 + 10} />
      <Hello name={name} age={age} />
      <Footer />
    </>
  )
}

It now compiles successfully, and the DOM generated by React no
longer contains the extra div-element.


*/

const Hello = (props) => {
  return (
    <div>
      <p>
        Hello {props.name}, you are {props.age} years old
      </p>
    </div>
  )
}

const App = () => {
  const name = 'Peter'
  const age = 10

  return (
    <div>
      <h1>Greetings</h1>
      <Hello name='Maya' age={26 + 10} />
      <Hello name={name} age={age} />
    </div>  
  )
}

export default App